# -*- coding: utf-8 -*-
"""Uyku BozukluÄŸu Tahmini_new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MndNAQ--yXj3x401pVBoisyl2F8N0O_E

# KÃ¼tÃ¼phanelerin Import Edilmesi
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import warnings
from termcolor import colored
import plotly.graph_objects as go
import plotly.figure_factory as ff
from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
warnings.filterwarnings("ignore")

"""# Verisetinin YÃ¼klenmesi"""

df = pd.read_csv('Uyku_verileri.csv')
df.head()

"""

*   Veriseti Kaggle'dan alÄ±nmÄ±ÅŸtÄ±r.
*   Toplam 374 satÄ±r ve 13 sÃ¼tundan oluÅŸmaktadÄ±r.
*   Tahmin yaptÄ±ÄŸÄ±mÄ±z sÃ¼tun "Sleep Disorder" .



"""

df.shape

"""# Veriseti HakkÄ±nda Bilgiler

**KiÅŸi KimliÄŸi** (Person ID): Her birey iÃ§in tanÄ±mlayÄ±cÄ± bir kimlik numarasÄ±.

**Cinsiyet** (Gender): KiÅŸinin cinsiyeti (Erkek/KadÄ±n).

**YaÅŸ** (Age): KiÅŸinin yaÅŸÄ± (yÄ±l olarak).

**Meslek** (Occupation): KiÅŸinin mesleÄŸi ya da yaptÄ±ÄŸÄ± iÅŸ.

**Uyku SÃ¼resi** (Saat) (Sleep Duration): KiÅŸinin gÃ¼nde kaÃ§ saat uyuduÄŸu.

**Uyku Kalitesi**  (1-10 arasÄ± Ã¶lÃ§ek) (Quality of Sleep): Uyku kalitesine dair 1 ile 10 arasÄ±nda Ã¶znel bir deÄŸerlendirme.

**Fiziksel Aktivite SÃ¼resi** (Dakika/gÃ¼n) (Physical Activity Level): KiÅŸinin gÃ¼nlÃ¼k olarak fiziksel aktiviteye ayÄ±rdÄ±ÄŸÄ± dakika sayÄ±sÄ±.

**Stres Seviyesi** (1-10 arasÄ± Ã¶lÃ§ek) (Stress Level): KiÅŸinin yaÅŸadÄ±ÄŸÄ± stres dÃ¼zeyine dair 1 ile 10 arasÄ±nda Ã¶znel bir deÄŸerlendirme.

**VÃ¼cut Kitle Ä°ndeksi Kategorisi** (BMI Category): KiÅŸinin VÃ¼cut Kitle Ä°ndeksi (VKÄ°) kategorisi (Ã¶rneÄŸin: ZayÄ±f, Normal, Kilolu, Obez).

**Tansiyon** (sistolik/diyastolik) (Blood Pressure): KiÅŸinin tansiyonu, bÃ¼yÃ¼k tansiyon / kÃ¼Ã§Ã¼k tansiyon ÅŸeklinde ifade edilir.

**NabÄ±z** (bpm) (Heart Rate): KiÅŸinin dakikadaki istirahat halindeki kalp atÄ±ÅŸ sayÄ±sÄ± (bpm: beats per minute).

**GÃ¼nlÃ¼k AdÄ±m SayÄ±sÄ±** (Daily Steps): KiÅŸinin bir gÃ¼nde attÄ±ÄŸÄ± adÄ±m sayÄ±sÄ±.

**Uyku BozukluÄŸu** (Sleep Disorder): KiÅŸide uyku bozukluÄŸu olup olmadÄ±ÄŸÄ± ( HastalÄ±k Yok, Ä°nsomnia, Uyku Apnesi).

# KeÅŸifsel Veri Analizi (Eda) - Exploratory Data Analysis
"""

column_names = df.columns.tolist()
print(column_names)

"""

*   Verisetindeki tÃ¼m sÃ¼tunlar


"""

df.info()

"""

*  5 sÃ¼tun object deÄŸerlerden oluÅŸuyor. Kalan sÃ¼tunlar numerik deÄŸerlerden oluÅŸmaktadÄ±r. Veri Ã¶n iÅŸleme adÄ±mÄ±nda object veriler sayÄ±sal verilere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸtÃ¼r.


"""

df.isnull().sum()

"""

*   BoÅŸ deÄŸer yoktur.


"""

df.describe()

deger_sayisi = (df.nunique())
print(deger_sayisi)

"""

*   Her sÃ¼tundaki eÅŸsiz (unique) deÄŸerlerin sayÄ±sÄ±nÄ± hesaplar.


"""

classes=df['Sleep Disorder'].unique()
print('SÄ±nÄ±flar :',classes)

"""

*  Uyku bozukluÄŸu sÄ±nÄ±flarÄ±nÄ± gÃ¶sterir.


"""

df['Sleep Disorder'].value_counts()

"""

*   SÄ±nÄ±f dengesizliÄŸi olduÄŸunu gÃ¶rebiliyoruz.
*   "No disorder" sÄ±nÄ±fÄ± 219 Ã¶rnekle baskÄ±n durumda.
*   "Sleep Apnea" ve "Insomnia" sÄ±nÄ±flarÄ± ise 77 ve 78 Ã¶rnekle azÄ±nlÄ±kta.




"""

import plotly.express as px

fig = px.histogram(
    df,
    x='Sleep Disorder',
    barmode="group",
    color='Sleep Disorder',
    color_discrete_sequence=['white', '#4A235A', '#C39BD3'],
    text_auto=True
)

fig.update_layout(
    title={
        'text': '<b>KiÅŸilerin Uyku BozukluÄŸu DaÄŸÄ±lÄ±mÄ±</b>',
        'x': 0.5,
        'xanchor': 'center',
        'font': {'size': 25}
    },
    xaxis_title='Uyku BozukluÄŸu',
    yaxis_title='KiÅŸi SayÄ±sÄ±',
    paper_bgcolor='#EBDEF0',
    plot_bgcolor='#EBDEF0',
    showlegend=True
)

fig.update_yaxes(showgrid=False)
fig.show()

"""# Veri Ã–n Ä°ÅŸleme (Data Processing)"""

df.drop(['Person ID'], axis=1, inplace=True)

"""

*  âœ… Person ID sÃ¼tunu verisetinden Ã§Ä±karÄ±lÄ±r.


"""

from sklearn import preprocessing
label_encoder = preprocessing.LabelEncoder()
df['Gender'] = label_encoder.fit_transform(df['Gender'])
df['Occupation'] = label_encoder.fit_transform(df['Occupation'])
df['BMI Category'] = label_encoder.fit_transform(df['BMI Category'])
df['Sleep Disorder'] = label_encoder.fit_transform(df['Sleep Disorder'])

"""

*  âœ… Her bir kategorik sÃ¼tun, LabelEncoder kullanÄ±larak 0, 1, 2 gibi sayÄ±sal deÄŸerlere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor.

*  Insomnia â†’ 0
*  None â†’ 1
*  Sleep Apnea â†’ 2







"""

df = pd.concat([df, df['Blood Pressure'].str.split('/', expand=True)], axis=1).drop('Blood Pressure', axis=1)
df = df.rename(columns={0: 'BloodPressure_Upper_Value', 1: 'BloodPressure_Lower_Value'})

"""Neden Blood Pressure sÃ¼tununda Label Encoding uygulamadÄ±k ?


*   LabelEncoder, kategorik (nitel) verileri sayÄ±lara dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin "Male", "Female" gibi sÄ±nÄ±flarÄ± 0 ve 1 gibi deÄŸerlere Ã§evirir. Ama "120/80", "140/90" gibi sayÄ±sal oranlarÄ± 0, 1, 2 gibi keyfi sayÄ±lara dÃ¶nÃ¼ÅŸtÃ¼rmek, verideki anlamÄ± bozar. Bu deÄŸerler bir sÄ±ralama ya da kategori deÄŸil, doÄŸrudan sayÄ±sal Ã¶lÃ§Ã¼mler.


*   AslÄ±nda burada **Feature Engineering** (Ã–zellik MÃ¼hendisliÄŸi) yapmÄ±ÅŸ olduk.

*   *  âœ… Verileri int tipine dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼k.
"""

df['BloodPressure_Upper_Value'] = df['BloodPressure_Upper_Value'].astype(int)
df['BloodPressure_Lower_Value'] = df['BloodPressure_Lower_Value'].astype(int)

"""

*   âœ… Tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼n kontrolÃ¼nÃ¼ yaptÄ±k.

"""

print(df['BloodPressure_Upper_Value'].dtype)
print(df['BloodPressure_Lower_Value'].dtype)

df.head()

plt.style.use('seaborn-v0_8-white')
sns.pairplot(data=df,hue='Sleep Disorder',palette='mako')
plt.legend()
plt.show()

correlation=df.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation, annot=True, fmt=".2f", annot_kws={"size":8}, linewidths=0.5, cmap='BuPu')
plt.title('TÃ¼m Ã–zelliklerin Korelasyon Analizi')
plt.tight_layout()
plt.show()

"""ğŸ” Ã–ne Ã‡Ä±kan Korelasyonlar:


*  ğŸ’¡ 1. Sleep Duration & Quality of Sleep: 0.88
Ã‡ok gÃ¼Ã§lÃ¼ bir pozitif korelasyon var.

Uyku sÃ¼resi arttÄ±kÃ§a uyku kalitesi de artÄ±yor â†’ mantÄ±klÄ± ve beklenen bir iliÅŸki.
*   ğŸ’¡ 2. Stress Level ile:
Sleep Duration: -0.81
Quality of Sleep: -0.90

Bu, stres arttÄ±kÃ§a hem uyku sÃ¼resi hem de kalitenin dÃ¼ÅŸtÃ¼ÄŸÃ¼nÃ¼ gÃ¶steriyor â†’ Ã§ok anlamlÄ± ve gÃ¼Ã§lÃ¼ negatif korelasyonlar.

*   ğŸ’¡ 3. BMI Category ile:
Blood Pressure Upper: 0.71
Blood Pressure Lower: 0.75

VÃ¼cut kitle indeksi arttÄ±kÃ§a kan basÄ±ncÄ± da artÄ±yor â†’ fizyolojik aÃ§Ä±dan anlamlÄ± bir sonuÃ§.
*   ğŸ’¡ 4. Daily Steps & Physical Activity Level: 0.77
Bu da beklenen bir sonuÃ§, fiziksel aktivite dÃ¼zeyi arttÄ±kÃ§a atÄ±lan adÄ±m sayÄ±sÄ± da artÄ±yor.

# âœ‚ï¸ Veri BÃ¶lme(Data Spliting)
"""

X = df.drop(['Sleep Disorder'], axis=1)
y = df['Sleep Disorder']

"""

*  ğŸ“Œ BaÄŸÄ±msÄ±z (X) ve baÄŸÄ±mlÄ± (y) deÄŸiÅŸkenlerin ayrÄ±lmasÄ±

*  ğŸ“Œ Hedef deÄŸiÅŸken "Sleep Disorder"





"""

X_train, X_test, y_train, y_test= train_test_split(X, y, test_size= 0.30, random_state=0)

print(len(X_train))
print(len(X_test))

"""# ğŸ” SMOTE


*  ğŸ“  SMOTE (Synthetic Minority Over-sampling Technique), dengesiz veri
kÃ¼melerinde azÄ±nlÄ±k sÄ±nÄ±fÄ±nÄ± artÄ±rarak daha dengeli bir veri daÄŸÄ±lÄ±mÄ± oluÅŸturmayÄ± amaÃ§layan bir yÃ¶ntemdir.
*  ğŸ“  SMOTE eÄŸitim veri setine uygulanÄ±r,test setine uygulanmaz.





"""

from sklearn.model_selection import train_test_split
from imblearn.over_sampling import SMOTE
smote = SMOTE(random_state=0)
X_train_res, y_train_res = smote.fit_resample(X_train, y_train)

print(y_train.value_counts())  # SMOTE uygulamadan Ã¶nceki sÄ±nÄ±f daÄŸÄ±lÄ±mÄ±
print(y_train_res.value_counts())  # SMOTE sonrasÄ± daÄŸÄ±lÄ±m

pip install lazypredict

"""# ğŸ” Lazy Predict"""

from lazypredict.Supervised import LazyClassifier

lazy_model = LazyClassifier(verbose=0, ignore_warnings=True, custom_metric=None)
models, predictions = lazy_model.fit(X_train, X_test, y_train, y_test)
print(models)

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier
from xgboost import XGBClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

"""# ğŸ”Hiperparametre AyarÄ±


*  ğŸš€ Hiperparametre ayarÄ± (Hyperparameter Tuning), makine Ã¶ÄŸrenimi modellerinin performansÄ±nÄ± optimize etmek iÃ§in kullanÄ±lan bir tekniktir. Hiperparametreler, modelin Ã¶ÄŸrenme sÃ¼recinde deÄŸiÅŸmeyen, Ã¶nceden belirlenmiÅŸ ayarlardÄ±r. DoÄŸru hiperparametre seÃ§imi, modelin doÄŸruluÄŸunu ve genelleme yeteneÄŸini artÄ±rabilir.



"""

pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('clf', RandomForestClassifier())
])
param_grid = [
    {
        'clf': [ExtraTreesClassifier()],
        'clf__n_estimators': [100, 200, 300],
        'clf__max_depth': [None, 5, 10],
    },
    {
        'clf': [XGBClassifier()],
        'clf__n_estimators': [100, 200, 300],
        'clf__learning_rate': [0.01, 0.1, 0.3],
    },
    {
        'clf': [RandomForestClassifier()],
        'clf__n_estimators': [100, 200, 300],
        'clf__max_depth': [None, 5, 10],
    },
    {
        'clf': [DecisionTreeClassifier()],
        'clf__max_depth': [None, 5, 10, 15],
    },
    {
        'clf': [SVC()],
        'clf__kernel': ['linear', 'rbf'],
        'clf__C': [0.01, 0.1, 1, 10],
    },
    {
        'clf': [LogisticRegression()],
        'clf__solver': ['liblinear', 'lbfgs'],
        'clf__C': [0.01, 0.1, 1, 10],
    }
]

grid_search = GridSearchCV(pipeline, param_grid, cv=5)
grid_search.fit(X_train, y_train)

best_model = grid_search.best_estimator_

models = [
    ('Extra Trees', ExtraTreesClassifier()),
    ('XGBClassifier', XGBClassifier()),
    ('Random Forest', RandomForestClassifier()),
    ('Decision Tree', DecisionTreeClassifier()),
    ('SVC', SVC()),
    ('Logistic Regression', LogisticRegression())
]

accuracy_scores = []
for name, model in models:
    pipeline = Pipeline([
        ('scaler', StandardScaler()),
        ('clf', model)
    ])
    pipeline.fit(X_train, y_train)
    y_pred = pipeline.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    accuracy_scores.append(accuracy)

fig = go.Figure(data=go.Bar(x=[name for name, _ in models], y=accuracy_scores))
fig.update_layout(title='Modellerin KarÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±',
                  xaxis=dict(title='Modeller'),
                  yaxis=dict(title='DoÄŸruluk'))
fig.show()

"""

*   âœ… En iyi model


"""

print("En iyi model:", grid_search.best_estimator_)

importance = best_model.named_steps['clf'].feature_importances_
feature_names = X.columns

sorted_indices = np.argsort(importance)[::-1]
sorted_importance = importance[sorted_indices]
sorted_features = feature_names[sorted_indices]

fig = go.Figure(data=go.Bar(x=sorted_features, y=sorted_importance))
fig.update_layout(title='Ã–zellik Ã–nem GrafiÄŸi',
                  xaxis=dict(title='Ã–zellikler'),
                  yaxis=dict(title='Ã–nem'))
fig.show()

"""# ğŸ¯ XGBClassifier Modelinin SonuÃ§larÄ±"""

best_params = grid_search.best_params_
{
    'clf': XGBClassifier(),
    'clf__n_estimators': 200,
    'clf__learning_rate': 0.1
}
from xgboost import XGBClassifier

xgb_best_params = {
    key.replace('clf__', ''): value
    for key, value in best_params.items()
    if key.startswith('clf__')
}

xgb_model = XGBClassifier(**xgb_best_params)

xgb_model.fit(X_train_res, y_train_res)

y_pred = xgb_model.predict(X_test)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

print("DoÄŸruluk:", accuracy_score(y_test, y_pred))

print("SÄ±nÄ±flandÄ±rma Raporu:\n", classification_report(y_test, y_pred))

cm = confusion_matrix(y_test, y_pred)
class_names = ['Insomnia', 'None', 'Sleep Apnea']
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Purples', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Tahmin Edilen')
plt.ylabel('GerÃ§ek')
plt.title('KarÄ±ÅŸÄ±klÄ±k Matrisi (Confusion Matrix)')
plt.show()

"""# Cross Validation


*   ğŸ“ŒÃ‡apraz doÄŸrulama (Cross-validation), makine Ã¶ÄŸrenimi modellerinin genelleÅŸtirme performansÄ±nÄ± deÄŸerlendirmek iÃ§in kullanÄ±lan bir tekniktir. Modelin farklÄ± veri alt kÃ¼meleri Ã¼zerinde nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in veri seti eÄŸitim ve test bÃ¶lÃ¼mlerine ayrÄ±lÄ±r ve bu iÅŸlem birden fazla kez tekrarlanÄ±r.
*   ğŸ“ŒStratified K-Fold: Veri seti sÄ±nÄ±f daÄŸÄ±lÄ±mÄ±nÄ± koruyarak bÃ¶lÃ¼nÃ¼r, Ã¶zellikle dengesiz veri kÃ¼melerinde faydalÄ±dÄ±r.

"""

from sklearn.model_selection import cross_val_score, StratifiedKFold
import numpy as np
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=0)
cv_scores = cross_val_score(xgb_model, X_train_res, y_train_res, cv=cv, scoring='accuracy')

print("Cross-Validation Scores:", cv_scores)
print("Mean Accuracy:", np.mean(cv_scores))
print("Standard Deviation:", np.std(cv_scores))

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc
import numpy as np

y_test_probs = xgb_model.predict_proba(X_test)
plt.figure(figsize=(8,6))
unique_classes = sorted(set(y_test))
colors = plt.cm.viridis(np.linspace(0, 1, len(unique_classes)))

for idx, cls in enumerate(unique_classes):
    fpr, tpr, _ = roc_curve(y_test, y_test_probs[:, idx], pos_label=cls)
    roc_auc = auc(fpr, tpr)
    plt.plot(fpr, tpr, color=colors[idx], label=f"{class_names[idx]} (AUC = {roc_auc:.2f})")

plt.plot([0,1], [0,1], linestyle="--", color="gray")

plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC EÄŸrisi - XGBClassifier")
plt.legend()
plt.show()

"""# AÃ§Ä±klamalÄ± Yapay Zeka

*  SHAP (Shapley Additive Explanations): Her Ã¶zelliÄŸin model tahminine olan katkÄ±sÄ±nÄ± hesaplar.
*  LIME (Local Interpretable Model-Agnostic Explanations): Modelin belirli bir tahmin iÃ§in nasÄ±l karar verdiÄŸini anlamak iÃ§in yerel aÃ§Ä±klamalar sunar.
"""

import shap
explainer = shap.Explainer(xgb_model)
shap_values = explainer(X_test)
shap.summary_plot(shap_values, X_test)

pip install lime

import lime
import lime.lime_tabular

explainer = lime.lime_tabular.LimeTabularExplainer(X_train_res.values, feature_names=X.columns, class_names=["Insomnia", "None", "Sleep Apnea"], mode="classification")

exp = explainer.explain_instance(X_test.iloc[0].values, xgb_model.predict_proba)
exp.show_in_notebook()